package cc.maxmc.dependencydownload;

import cc.maxmc.dependencydownload.dependency.JarMavenObject;
import cc.maxmc.dependencydownload.downloader.FileDownloader;
import cc.maxmc.dependencydownload.downloader.SingleThreadFileDownloader;
import cc.maxmc.dependencydownload.path.DependencyPathProvider;
import cc.maxmc.dependencydownload.path.DirectoryDependencyPathProvider;
import cc.maxmc.dependencydownload.relocation.Relocation;
import cc.maxmc.dependencydownload.resource.DependencyDownloadResource;
import com.google.errorprone.annotations.CheckReturnValue;
import org.jetbrains.annotations.NotNull;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.Executor;

/**
 * An application level dependency manager to prevent loading in the same dependency multiple times.
 */
@SuppressWarnings("unused") // API
public class ApplicationDependencyManager {

    private final Set<JarMavenObject> dependencies = new CopyOnWriteArraySet<>();
    private final Set<Relocation> relocations = new CopyOnWriteArraySet<>();

    private final DependencyPathProvider dependencyPathProvider;

    /**
     * Creates a {@link ApplicationDependencyManager}, uses the {@link DirectoryDependencyPathProvider}.
     *
     * @param cacheDirectory the directory used for downloaded and relocated dependencies.
     * @see DirectoryDependencyPathProvider
     */
    public ApplicationDependencyManager(@NotNull Path cacheDirectory) {
        this(new DirectoryDependencyPathProvider(cacheDirectory));
    }

    /**
     * Creates a {@link ApplicationDependencyManager}.
     *
     * @param dependencyPathProvider the dependencyPathProvider used for downloaded and relocated dependencies
     */
    public ApplicationDependencyManager(@NotNull DependencyPathProvider dependencyPathProvider) {
        this.dependencyPathProvider = dependencyPathProvider;
    }

    /**
     * Adds the provided relocations to this {@link ApplicationDependencyManager},
     * they will be used in all {@link DependencyManager}s created by this manager after being added.
     *
     * @param relocations the relocations to add
     * @see #addRelocation(Relocation)
     */
    public void addRelocations(@NotNull Collection<Relocation> relocations) {
        this.relocations.addAll(relocations);
    }

    /**
     * Adds the provided relocation to this {@link ApplicationDependencyManager},
     * it will be used in all {@link DependencyManager}s created by this manager after being added.
     *
     * @param relocation the relocation
     * @see #addRelocations(Collection)
     */
    public void addRelocation(@NotNull Relocation relocation) {
        this.relocations.add(relocation);
    }

    /**
     * Includes the dependencies and relocations from the dependency resource generated
     * by the gradle plugin, located by the provided {@link URL}.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param resourceURL the url to the resource generated by the gradle plugin
     * @param executor    executor used to execute the task
     * @return the {@link DependencyManager} to load in the dependencies
     * @throws IOException if reading the file from the {@link URL} fails
     */
    @CheckReturnValue
    public DependencyManager includeResource(@NotNull URL resourceURL, Executor executor) throws IOException {
        DependencyDownloadResource resource = new DependencyDownloadResource(resourceURL);
        return includeResource(resource, executor);
    }

    /**
     * Includes the dependencies and relocations from the dependency resource generated
     * by the gradle plugin, provided as the {@link String} content of the resource.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param resourceContent the full contents of the resource generated by the gradle plugin
     * @param executor the executor to execute the task
     * @return the {@link DependencyManager} to load in the dependencies
     */
    @CheckReturnValue
    public DependencyManager includeResource(@NotNull String resourceContent, Executor executor) {
        DependencyDownloadResource resource = new DependencyDownloadResource(resourceContent);
        return includeResource(resource, executor);
    }

    /**
     * Includes the dependencies and relocations from the dependency resource generated
     * by the gradle plugin, provided as a list of lines from the resource.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param resourceLines all the lines of the resource generated by the gradle plugin
     * @param executor the executor to execute the task
     * @return the {@link DependencyManager} to load in the dependencies
     */
    @CheckReturnValue
    public DependencyManager includeResource(@NotNull List<String> resourceLines, Executor executor) {
        DependencyDownloadResource resource = new DependencyDownloadResource(resourceLines);
        return includeResource(resource, executor);
    }

    /**
     * Includes the dependencies and relocations from the {@link DependencyDownloadResource} provided as an argument.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param resource the resource to get dependencies and relocations from
     * @param executor the executor to execute the task
     * @return the {@link DependencyManager} to load in the dependencies
     */
    public DependencyManager includeResource(@NotNull DependencyDownloadResource resource, Executor executor) {
        return include(resource.getDependencies(), resource.getRelocations(), executor);
    }

    /**
     * Includes the provided dependencies and relocations.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param dependencies the dependencies to include
     * @param relocations  the relocations to include
     * @param executor the executor to execute the task
     * @return the {@link DependencyManager} to load in the dependencies
     */
    @CheckReturnValue
    public DependencyManager include(@NotNull List<JarMavenObject> dependencies, @NotNull List<Relocation> relocations, Executor executor) {
        addRelocations(relocations);
        return include(dependencies, executor);
    }

    /**
     * Includes the provided dependencies.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param dependencies the dependencies to include
     * @param executor the executor to execute the task
     * @return the {@link DependencyManager} to load in the dependencies
     */
    @CheckReturnValue
    public DependencyManager include(@NotNull Collection<JarMavenObject> dependencies, Executor executor) {
        dependencies = dependencies(dependencies);
        FileDownloader downloader = new SingleThreadFileDownloader();

        DependencyManager manager = new DependencyManager(dependencyPathProvider, downloader, executor);
        manager.addDependencies(dependencies);
        manager.addRelocations(this.relocations);
        return manager;
    }

    /**
     * Includes the dependencies and relocations from the provided {@link DependencyManager}, the {@link DependencyPathProvider} will be preserved.
     * <p>
     * The returned {@link DependencyManager} will only include dependencies that have not been downloaded yet,
     * and will include all the relocations from this manager.
     *
     * @param manager the manager to get dependencies and relocations from
     * @param executor the executor to execute the task
     * @return a new {@link DependencyManager} to load in the dependencies
     */
    @CheckReturnValue
    public DependencyManager include(@NotNull DependencyManager manager, Executor executor) {
        addRelocations(manager.getRelocations());
        List<JarMavenObject> dependencies = dependencies(manager.getDependencies());
        FileDownloader downloader = new SingleThreadFileDownloader();

        DependencyManager dependencyManager = new DependencyManager(manager.getDependencyPathProvider(), downloader, executor);
        dependencyManager.addDependencies(dependencies);
        dependencyManager.addRelocations(this.relocations);
        return dependencyManager;
    }

    private List<JarMavenObject> dependencies(Collection<JarMavenObject> old) {
        List<JarMavenObject> newDependencies = new ArrayList<>(old.size());
        for (JarMavenObject mavenObject : old) {
            String group = mavenObject.getGroupId();
            String artifact = mavenObject.getArtifactId();

            // Check that there is no dependency with the same group + artifact id
            boolean noMatch = this.dependencies.stream()
                    .noneMatch(dep -> dep.getGroupId().equals(group)
                            && dep.getArtifactId().equals(artifact));

            if (noMatch && this.dependencies.add(mavenObject)) {
                newDependencies.add(mavenObject);
            }
        }
        return newDependencies;
    }
}
